笔记：
一、命名空间的using声明
1、string表示可变长的字符序列，vector存放的是某种给定类型对象的可变长序列。

2、using声明具有如下的形式：
using namespace::name;

3、位于头文件的代码一般来说不应该试用using声明。这是因为头文件的内容会拷贝到所有引用它的文件中去。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。

二、标准库类型string
1、下面是初始化string对象最常用的一些方式：
string s1;				// 默认初始化，s1是一个空字符串
string s2(s1);			// s2是s1的副本
string s2 = s1;			// 等价于s2(s1)，s2是s1的副本
string s3 = "hiya";		// s3是该字符串字面值的副本,除了字面值最后的那个空字符外
string s4(5, 'c');		// s4的内容是ccccc

2、如果使用等号(=)初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是直接初始化。

3、当初始值只有一个时，使用直接初始化或拷贝初始化都行。如果像上面s4那样初始化要用到的值有多个，一般来说只能使用直接初始化的方式。

4、下面例子中，在执行读取操作时，string对象会自动忽略掉开头的空白(即空格符、换行符、制表符等)并从第一个真正的字符开始读起，直到遇见下一处空白为止。
string s;
cin >> s; // 将string对象读入s，遇到空白停止

5、while(cin >> s) //反复读取，直至到达文件末尾

6、getline函数的参数是一个输入流和一个string字符串，函数从给定的输入流读入内容，直到遇到换行符为止(注意换行符也被读进来了)，然后把所读的内容存入到那个string对象中去(注意不存换行符,被丢弃了)。getline只有一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空string。
while(getline(cin, line))	// 每次读入一整行，直到到达文件末尾
	cout << line << endl;	// 使用endl结束当前行并刷新显示缓冲区

7、size函数返回string对象的长度(即string对象中字符的个数)。
其实size函数返回的是一个string::size_type类型的值，它是一个无符号类型的值，而且能够存放下任何string对象的大小。在C++11中，允许编译器通过auto或者decltype来推断变量的类型: auto len = line.size();
注意：由于size函数返回的是一个无符号整型数，所以如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。例如，假设n是一个具有负值的int，则表达式s.size() < n的判断结果几乎肯定是true。这是因为负值n会自动地转换成一个比较大的无符号值。

8、string("abcde")对象小于string("aj")

9、当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符(+)的两侧的运算对象至少有一个是string。
string s5 = "hello" + ", ";			// 错误: 两个运算对象都不是string
string s6 = s1 + ", " + "world";	// 正确：每个加法运算符都有一个运算对象是string
string s7 = "hello" + ", " + s2;	// 错误：不能把字面值直接相加。这相等于string s7 = ("hello" + ", ") + s2;是错误的
切记：C++语言中的字符串字面值并不是标准库类型string的对象。

10、判断某个字符的特性可以包含头文件cctype使用相关的库函数。

11、C语言的头文件形如name.h，C++语言则将这些文件命名为cname。也就是去掉了.h后缀，而在文件名name之前添加了字母c，这里的c表示这是一个属于C语言标准库的头文件。特别的，在名为cname的头文件中定义的名字从属于名称空间std，而定义在名为.h的头文件中的则不然。一般来说，C++程序应该使用名为cname的头文件而不使用name.h的形式，标准库中的名字总能在命名空间std中找到。

12、string对象的下标必须大于等于0而小于s.size()。使用超出此范围的下表将引发不可预知的结果，以此推断，使用下标访问空string也会引发不可预知的结果。

13、下标的值称作"下标"或"索引"，任何表达式只要它的值是一个整型值就能作为索引。不过，如果某个索引是带符号类型的值将自动转换成由string::size_type表达的无符号类型。

14、不管什么时候，只要对string对象使用了下标，都要确认在那个位置上确实有值。

15、if(a>1 && b>5);	// C++语言规定只有当左侧运算对象为真时才会检查右侧运算对象的情况。

16、使用下标时必须确保其在合理范围之内，也就是说，下标必须大于等于0,而小于字符串的size()的值。一种简答易行的方法是，总是设下标的类型为string::size_type，因为此类型是无符号数，可以确保下标不会小于0。此时，代码只需保证下标小于size()的值就可以了。

三、标准库类型vector
1、标准库类型vector表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。因为vector"容纳着"其他对象，所以它也常被称作容器。

2、C++语言既有类模板，也有函数模板，其中vector是一个类模板。
模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为实例化，当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

3、vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector<int>。

4、vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的vector。

5、特别指出，在早期版本的C++标准中，如果vector的元素还是vector(或者其他模板类型)
，则其定义的形式与现在C++11新标准略有不同。过去，必须在外层vector对象的右尖括号和其元素类型之间添加一个空格，如应该写成vector<vector<int> >而非vector<vector<int>>。

6、可以默认初始化vector对象，从而创建一个指定类型的空vector。
如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里。

7、通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。
vector<string> svec(10);		// 10个元素，每个都是空string对象
对这种初始化的方式有两个特殊限制：其一，有些类要求必须明确地提供初始值，如果vector对象中元素的类型不支持默认初始化，我们就必须提供初始的元素值。对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作。其二，如果只提供了元素的数量而没有设定初始值，只能使用直接初始化。

8、花括号与圆括号的区别：
vector<int> v1(10);			// v1有10个元素，每个的值都是0
vector<int> v2{10};			// v2有1个元素，该元素的值是10
vector<int> v3(10, 1);		// v3有10个元素，每个的值都是1
vector<int> v4{10, 1};		// v4有2个元素，值分别是10和1
如果用的是圆括号，可以说提供的值是用来构造vector对象的。如果用的是花括号，可以表述成我们想列表初始化该vector对象。

另一方面，如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造vector对象了。(确定无法执行列表初始化后，编译器会尝试用默认值初始化vector对象)
vector<string> v5{"hi"};	// 列表初始化：v5有一个元素
vector<string> v6("hi");	// 错误：不能使用字符串字面值构建vector对象
vector<string> v7{10};		// v7有10个默认初始化的元素
vector<string> v8{10, "hi"};// v8有10个值为"hi"的元素

9、对vector对象来说，直接初始化的方式适用于三种情况：初始值已知且数量较少、初始值是另一个vector对象的副本、所有元素的初始值都一样。

10、C++标准要求vector应该能在运行时高效快速地添加元素。
注意：如果循环体内部包含有向vector对象添加元素的语句，则不能使用范围for循环。即范围for语句体内不应改变其所遍历序列的大小。(详看C++ Primer 5e P168)

11、

四、迭代器介绍


五、数组


六、多维数组



一些术语：
1、



















