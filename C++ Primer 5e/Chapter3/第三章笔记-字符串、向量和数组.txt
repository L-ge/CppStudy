笔记：
一、命名空间的using声明
1、string表示可变长的字符序列，vector存放的是某种给定类型对象的可变长序列。

2、using声明具有如下的形式：
using namespace::name;

3、位于头文件的代码一般来说不应该试用using声明。这是因为头文件的内容会拷贝到所有引用它的文件中去。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。

二、标准库类型string
1、下面是初始化string对象最常用的一些方式：
string s1;				// 默认初始化，s1是一个空字符串
string s2(s1);			// s2是s1的副本
string s2 = s1;			// 等价于s2(s1)，s2是s1的副本
string s3 = "hiya";		// s3是该字符串字面值的副本,除了字面值最后的那个空字符外
string s4(5, 'c');		// s4的内容是ccccc

2、如果使用等号(=)初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是直接初始化。

3、当初始值只有一个时，使用直接初始化或拷贝初始化都行。如果像上面s4那样初始化要用到的值有多个，一般来说只能使用直接初始化的方式。

4、下面例子中，在执行读取操作时，string对象会自动忽略掉开头的空白(即空格符、换行符、制表符等)并从第一个真正的字符开始读起，直到遇见下一处空白为止。
string s;
cin >> s; // 将string对象读入s，遇到空白停止

5、while(cin >> s) //反复读取，直至到达文件末尾

6、getline函数的参数是一个输入流和一个string字符串，函数从给定的输入流读入内容，直到遇到换行符为止(注意换行符也被读进来了)，然后把所读的内容存入到那个string对象中去(注意不存换行符,被丢弃了)。getline只有一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空string。
while(getline(cin, line))	// 每次读入一整行，直到到达文件末尾
	cout << line << endl;	// 使用endl结束当前行并刷新显示缓冲区

7、size函数返回string对象的长度(即string对象中字符的个数)。
其实size函数返回的是一个string::size_type类型的值，它是一个无符号类型的值，而且能够存放下任何string对象的大小。在C++11中，允许编译器通过auto或者decltype来推断变量的类型: auto len = line.size();
注意：由于size函数返回的是一个无符号整型数，所以如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果。例如，假设n是一个具有负值的int，则表达式s.size() < n的判断结果几乎肯定是true。这是因为负值n会自动地转换成一个比较大的无符号值。

8、string("abcde")对象小于string("aj")

9、当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符(+)的两侧的运算对象至少有一个是string。
string s5 = "hello" + ", ";			// 错误: 两个运算对象都不是string
string s6 = s1 + ", " + "world";	// 正确：每个加法运算符都有一个运算对象是string
string s7 = "hello" + ", " + s2;	// 错误：不能把字面值直接相加。这相等于string s7 = ("hello" + ", ") + s2;是错误的
切记：C++语言中的字符串字面值并不是标准库类型string的对象。

10、判断某个字符的特性可以包含头文件cctype使用相关的库函数。

11、C语言的头文件形如name.h，C++语言则将这些文件命名为cname。也就是去掉了.h后缀，而在文件名name之前添加了字母c，这里的c表示这是一个属于C语言标准库的头文件。特别的，在名为cname的头文件中定义的名字从属于名称空间std，而定义在名为.h的头文件中的则不然。一般来说，C++程序应该使用名为cname的头文件而不使用name.h的形式，标准库中的名字总能在命名空间std中找到。

12、string对象的下标必须大于等于0而小于s.size()。使用超出此范围的下表将引发不可预知的结果，以此推断，使用下标访问空string也会引发不可预知的结果。

13、下标的值称作"下标"或"索引"，任何表达式只要它的值是一个整型值就能作为索引。不过，如果某个索引是带符号类型的值将自动转换成由string::size_type表达的无符号类型。

14、不管什么时候，只要对string对象使用了下标，都要确认在那个位置上确实有值。

15、if(a>1 && b>5);	// C++语言规定只有当左侧运算对象为真时才会检查右侧运算对象的情况。

16、使用下标时必须确保其在合理范围之内，也就是说，下标必须大于等于0,而小于字符串的size()的值。一种简答易行的方法是，总是设下标的类型为string::size_type，因为此类型是无符号数，可以确保下标不会小于0。此时，代码只需保证下标小于size()的值就可以了。

三、标准库类型vector


四、迭代器介绍


五、数组


六、多维数组



一些术语：
1、



















