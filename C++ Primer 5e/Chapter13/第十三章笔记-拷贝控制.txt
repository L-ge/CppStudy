笔记：
一、拷贝、赋值与销毁
1、拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么。我们称这些操作为拷贝控制操作。
2、如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。
拷贝构造函数的第一个参数必须是一个引用类型(因为拷贝构造函数被用来初始化非引用类类型参数，否则定义就是死循环)。虽然我们可以定义一个接收非const引用的拷贝构造函数，但此参数几乎总是一个const的引用。
拷贝构造函数在几种情况下都会被隐式地使用。因此，拷贝构造函数通常不应该是explicit的。

3、如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。
对某些类来说，合成拷贝构造函数用来阻止我们拷贝该类类型的对象。而一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中。
每个成员的类型决定了它如何拷贝：对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。

4、直接初始化和拷贝初始化之间的差异：
当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。
当我们使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。

5、拷贝初始化通常使用拷贝构造函数来完成，有时会使用移动构造函数来完成。
6、拷贝初始化不仅在我们用=定义变量时会发生，在下列情况下也会发生：
①将一个对象作为实参传递给一个非引用类型的形参；
②从一个返回类型为非引用类型的函数返回一个对象；
③用花括号列表初始化一个数组中的元素或一个聚合类中的成员。

7、当我们初始化标准库容器或是调用其insert或push成员时，容器会对其元素进行拷贝初始化。与之相对，用emplace成员创建的元素都进行直接初始化。
8、在拷贝初始化过程中，编译器可以(但不是必须)跳过拷贝/移动构造函数，直接创建对象。
即编译器被允许将下面的代码：
string null_book = "9-999-999";	// 拷贝初始化
改写成：
string null_book("9-999-999");	// 编译器略过了拷贝构造函数
但是，即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是存在且可访问的(例如不是private的)。

9、与类控制其对象如何初始化一样，类也可以控制其对象如何赋值。
与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。

10、值得注意的是，标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。
赋值运算符通常应该返回一个指向其左侧运算对象的引用。

11、与处理拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符。类似拷贝构造函数，对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值。如果拷贝赋值运算符并非出于此目的，它会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，这一工作是通过成员类型的拷贝赋值运算符来完成的。对于数组类型的成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。

12、析构函数执行与构造函数相反的操作。析构函数释放对象使用的资源，并销毁对象的非static数据成员。
13、由于析构函数不接受参数，因此它不能被重载。对于一个给定类，只会有唯一一个析构函数。
14、在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员。成员按照初始化顺序的逆序销毁。
15、隐式销毁一个内置指针类型的成员不会delete它所指向的对象。
与普通指针不同，智能指针是类类型，所以具有析构函数。因此，与普通指针不同，智能指针成员在析构阶段会被自动销毁。
16、当指向一个对象的引用或指针离开作用域时，析构函数不会执行。
17、认识到析构函数体自身并不直接销毁成员是非常重要的。成员是在析构函数体之外隐含的析构阶段中被销毁的。在整个对象销毁的过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。

18、如果一个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。
如果使用合成的拷贝构造函数和拷贝赋值运算符，这些函数简单拷贝指针成员，意味着多个类对象可能指向相同的内存。

19、如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符；反之亦然。然而，无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数。

20、我们可以通过将拷贝控制成员定义为=default来显式地要求编译器生成合成的版本。
当我们在类内用=default修饰成员的声明时，合成的函数将隐式地声明为内联的(就像任何其他类内声明的成员函数一样)。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用=default。
我们只能对具有合成版本的成员函数使用=default(即，默认构造函数或拷贝控制成员)。

21、在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝。删除的函数是这样的一种函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加上=delete来指出我们希望将它定义为删除的：
与=default不同，=delete必须出现在函数第一次声明的时候，这个差异与这些声明的含义在逻辑上是吻合的。
与=default的另一个不同之处是，我们可以对任何函数指定=delete(我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用=default)。虽然删除函数的主要用途是禁止拷贝控制成员，但当我们希望引导函数匹配过程时，删除函数有时也是有用的。

22、值得注意的是，我们不能删除析构函数。
23、对某些类来说，编译器将这些合成的成员定义为删除的函数：
①如果类的某个成员的析构函数是删除的或不可访问的(例如是pivate的)，则类的合成析构函数被定义为删除的。
②如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的。
③如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。
④如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个const成员，它没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的。
本质上，这些规则的含义是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。

24、在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private的来阻止拷贝。
25、当拷贝构造函数和拷贝赋值运算符是private的，用户代码将不能拷贝这个类型的对象。但是，友元和成员函数仍旧可以拷贝对象。为了阻止友元和成员函数进行拷贝，我们将这些拷贝控制成员声明为private的，但并不定义它们。
声明但不定义一个成员函数是合法的。试图访问一个未定义的成员将导致一个链接时错误。
通过声明(但不定义)private的拷贝构造函数，我们可以预先阻止任何拷贝该类型对象的企图：试图拷贝对象的用户代码将在编译阶段被标记为错误；成员函数或友元函数中的拷贝操作将会导致链接时错误。
但是，新标准发布之后，希望阻止拷贝的类应该使用=delete来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为private的。

26、class中，无访问说明符时，成员默认是private的。

二、拷贝控制和资源管理
1、通常，管理类外资源的类必须定义拷贝控制成员。
2、通常，类直接拷贝内置类型(不包括指针)成员；这些成员本身就是值，因此通常应该让它们的行为像值一样(拷贝的时候，副本和原对象是完全独立的，改变副本不会对原对象有任何影响)，而不是像指针一样(拷贝的时候，副本和原对象使用相同的底层数据，改变副本也会改变原对象)。
3、当你编写赋值运算符时，有两点需要记住：
①如果将一个对象赋予它自身，赋值运算符必须能正确工作；
②大多数赋值运算符组合了析构函数和拷贝构造函数的工作。
当你编写一个赋值运算符时，一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。
4、引用计数的工作方式如下：
①除了初始化对象外，每个构造函数(拷贝构造函数除外)还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1。
②拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享。
③析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态。
④拷贝赋值运算符递增右侧运算对象的计算器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。
另外，注意要将计数器保存在动态内存中。

三、交换操作
1、使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值。

四、拷贝控制示例
1、


五、动态内存管理类
1、


六、对象移动
1、


一些术语：
1、














