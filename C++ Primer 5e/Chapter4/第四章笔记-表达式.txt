笔记：
一、基础
1、C++定义了一元运算符和二元运算符。作用于一个运算对象的运算符是一元运算符，以此类推。
2、在表达式求值的过程中，运算对象常常由一种类型转换成另外一种类型。例如，尽管一般的二元运算符都要求两个运算对象的类型相同，但是很多时候即使运算对象的类型不相同也没有关系，只要它们能被转换成同一种类型即可。
小整数类型(如bool、char、short等)通常会被提升成较大的整数类型，主要是int。

3、当运算符作用于类类型的运算对象时，用户可以自行定义其含义。因为这种自定义的过程事实上是为已存在的运算符赋予了另外一层定义，所以称之为重载运算符。
我们使用重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。

4、C++的表达式要不然是右值，要不然就是左值。
一个左值表达式的求值结果是一个对象或者一个函数，然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象。
一个对象被用作右值的时候，用的是对象的值(内容)；当对象被用作左值的时候，用的是对象的身份(在内存中的位置)。
一个重要的原则是在需要右值的地方可以用左值来代替，但是不能把右值当成左值(也就是位置)使用。当一个左值被当成右值使用时，实际使用的是它的内容(值)。

5、使用关键字decltype的时候，左值和右值也有所不同。如果表达式的求值结果是左值，decltype作用于该表达式(不是变量)得到一个引用类型。例如，假定p的类型是int*，因为解引用运算符生成左值，所以decltype(*p)的结果是int&。另一方面，因为取地址运算符生成右值，所以decltype(&p)的结果是int**，也就是说，结果是一个指向整型指针的指针。

6、算术运算符满足左结合律，意味着如果运算符的优先级相同，将按照从左向右的顺序组合运算对象。

7、括号无视优先级与结合律。

8、C++ Primer 5e第147页罗列出了全部的运算符，并用双横线将它们分割成若干组。同一组内的运算符优先级相同，组的位置越靠前组内的运算符优先级越高。

9、下面的输出表达式是未定义的：
int i = 0;
cout << i << " " << ++i << endl;

10、运算对象的求值顺序与优先级和结合律无关，在一条形如f()+g()*h()+j()的表达式中，对于这些函数的调用顺序没有明确规定。如果f、g、h和j是无关函数，它们既不会改变同一对象的状态也不执行IO任务，那么函数的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为。

11、以下两条经验准则对书写复合表达式有益:
①拿不准的时候最好用括号来强制让表达式的组合关系复合程序逻辑的要求。
②如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。
第2条准则有一个重要例外，当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。例如，在表达式*++iter中，递增运算符改变iter的值，iter(已经改变)的值又是解引用运算符的运算对象。此时(或类似的情况下)，求值的顺序不会成为问题，因为递增运算(即改变运算对象的子表达式)必须先求值，然后才轮到解引用运算。

二、算术运算符
1、算术运算符的运算对象和求值结果都是右值。
2、一元负号运算符对运算对象值取负后，返回其(提升后的)副本。
int i = 1024;
int k = -i;		// k是-1024
bool b = true;
bool b2 = -b;	// b2是true!
布尔值不应该参与运算。对大多数运算符来说，布尔类型的运算对象将被提示为int类型，所上面例子，布尔变量b的值是真，参与运算时将被提示成整数值1，对它求负后的结果是-1。将-1再转换回布尔值并将其作为b2的初始值，显然这个初始值不等于0，转换成布尔值后应该为1，所以b2的值是真。

3、参与取余运算的运算对象必须是整数类型，否则错误。

4、在除法运算中，如果两个运算对象的符号相同则商为正(如果不为0的话)，否则商为负。C++语言的早期版本允许结果为负值的商向上或向下取整，C++11新标准则规定商一律向0取整(即直接切除小数部分)。
根据取余运算的定义，如果m和n是整数且n非0，则表达式(m/n)*n+m%n的求值结果与m相等。隐含的意思是，如果m%n不等于0，则它的符号和m相同。C++语言的早期版本允许m%n的符号匹配n的符号，而且商向负无穷一侧取整，这一方式在新标准中已经被禁止使用了。除了-m导致溢出的特殊情况外，其他时候(-m)/n和m/(-n)都等于-(m/n)，m%(-n)等于m%n，(-m)%n等于-(m%n)。

三、逻辑和关系运算符
1、值为0的运算对象(算术类型或指针类型)表示假，否则表示真。
2、对于这两类运算符来说，运算对象和求值结果都是右值。
3、逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为短路求值。
4、string对象可能非常大，将string对象s声明成引用类型可以避免对元素的拷贝，如果又不需要对string对象做写操作，可以将s声明成对常量的引用。
5、当布尔值转换成其他算术类型时，false转换成0而true转换成1。
6、注意：进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象。

四、赋值运算符
1、赋值运算符的左侧运算对象必须是一个可修改的左值。
int i = 0;			// 初始化而非赋值
const int ci = i; 	// 初始化而非赋值

2、赋值运算的结果是它的左侧运算结果，并且是一个左值。
3、C++11新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象。
无论左侧运算对象的类型是什么，初始值列表都可以为空。此时，编译器创建一个值初始化的临时量并将其赋给左侧运算对象。
4、赋值运算符满足右结合律。
5、因为赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号。
6、复合赋值运算符(例如+=、-=、<<=等)都完全等价于a = a op b;
这之间唯一的区别是左侧运算对象的求值次数：使用复合运算符只求值一次，使用普通的运算符则求值两次。这种区别除了对程序性能有些许影响外几乎可以忽略不计。

五、递增和递减运算符
1、除非必须，否则不用递增递减运算符的后置版本。(也就是多用++i，少用i++)
2、后置递增运算符的优先级高于解引用运算符，因此*p++等价于*(p++).
"cout << *p++ << endl;"语句输出p开始时指向的那个元素，并将指针向前移动一个位置。

六、成员访问运算符
1、箭头运算符作用于一个指针类型的运算对象，结果是一个左值。点运算符分成两种情况：如果成员所属的对象是左值，那么结果是左值；反之，如果成员所属的对象是右值，那么结果是右值。

七、条件运算符
1、当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值。
2、条件运算符满足右结合律，意味着运算对象(一般)按照从右到左的顺序组合。
3、随着条件运算符嵌套层数的增加，代码的可读性急剧下降。因此，条件运算的嵌套最好别超过两到三层。
4、注意：条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算子表达式时，通常需要在它两端加上括号。

八、位运算符
1、位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。位运算符提供检查和设置二进制位的功能。
运算对象可以是带符号的，也可以是无符号的。如果运算对象是带符号的且它的值为负，那么位运算符如何处理运算对象的"符号位"依赖于机器。而且，此时的左移操作可能会改变符号位的值，因此是一种未定义的行为。
注意：关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符用于处理无符号类型。
2、一般来说，如果运算对象是"小整型"，则它的值会被自动提升。
unsigned char bits = 0233; 	// 0233是八进制的字面值	
bits << 8;					// bits提升为int类型，然后左移了8位
3、移位运算符(又叫IO运算符)满足左结合律。
移位运算符的优先级不高不低，介于中间：比算术运算符的优先级低，但比关系运算符、赋值运算符和条件运算符的优先级高。

九、sizeof运算符
1、sizeof运算符返回一个表达式或一个类型名字所占的字节数。
sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。

2、sizeof运算符的结果部分地依赖于其作用的类型：
①对char或者类型为char的表达式执行sizeof运算符，结果得1。
②对引用类型执行sizeof运算符得到被引用对象所占空间的大小。
③对指针执行sizeof运算得到指针本身所占空间的大小。
④对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效。
⑤对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理。
⑥对string对象或vector对象执行sizeof运算符只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。

3、因为执行sizeof运算符能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中元素的个数：
constexpr size_t sz = sizeof(ia)/sizeof(*ia);
因为sizeof的返回值是一个常量表达式，所以我们可以用sizeof的结果声明数组的维度。

十、逗号运算符
1、逗号运算符含有两个运算对象，按照从左向右的顺序依次求值。
2、对于逗号运算符来说，首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。

十一、类型转换
1、在下面这些情况下，编译器会自动地转换运算对象的类型：
①在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。
②在条件中，非布尔值转换成布尔类型。
③初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。
④如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。
⑤函数调用时也会发生类型转换。

2、整型提升负责把小整数类型转换成较大的整数类型。对于bool、char、signed char、unsigned char、short和unsigned short等类型来说，只要它们所有可能的值都能存在int里，它们就会提升成int类型；否则，提升成unsigned int类型。例如布尔值false提升成0，true提升成1.
较大的char类型(wchar_t、char16_t、char32_t)提升成int、unsigned int、long、unsigned long、long long和unsigned long long中最小的一种类型，前提是转换后的类型要能容纳原类型所有可能的值。

3、除了算术转换之外，还有几种隐式类型转换，包括如下几种。
①数组转换成指针：在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。
当数组被用作decltype关键字的参数，或者作为取地址符、sizeof及typeid等运算符的运算对象时，上述转换不会发生。同样的，如果用一个引用来初始化数组，上述转换也不会发生。当在表达式中使用函数类型时会发生类似的指针转换。
②指针的转换：C++还规定了几种其他的指针转换方式，包括常量整数值0或者字面值nullptr能转换成任意指针类型；指向任意非常量的指针能转换成void*；指向任意对象的指针能转换成const void*。在有继承关系的类型间还有另外一种指针转换的方式。
③转换成布尔类型：存在一种从算术类型或指针类型向布尔类型自动转换的机制。如果指针或算术类型的值为0，转换结果是false；否则转换结果是true。
④转换成常量：允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样。也就是说，如果T是一种类型，我们就能将指向T的指针或引用分别转换成指向const T的指针或引用。相反的转换并不存在，因为它试图删除掉底层const。
⑤类类型定义的转换：类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换。

4、虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的。

5、一个命名的强制类型转换具有如下形式：
cast-name<type>(expression);
其中，type是转换的目标类型而expression是要转换的值。如果type是引用类型，则结果是左值。cast-name是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种。dynamic_cast支持运行时类型识别。cast-name指定了执行的是哪种转换。

6、任何具有明确定义的类型转换，主要不包括底层const，都可以使用static_cast。
当需要把一个较大的算术类型赋值给较小的类型时，static_cast非常有用。
static_cast对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast找回存在于void*指针中的值。
void* p = &d;							// 正确：任何非常量对象的地址都能存入void*
double *dp = static_cast<double*>(p);	// 正确：将void*转换回初始的指针类型
当我们把指针存放在void*中，并且使用static_cast将其强制转换回原来的类型时，应该确保指针的值保持不变。也就是说，强制转换的结果将与原始的地址值相等，因此我们必须确保转换后所得的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果。

7、const_cast只能改变运算对象的底层const。
const char *pc;
char *p = const_cast<char*>(pc); // 正确：但是通过p写值是未定义的行为
对于将常量对象转换成非常量对象的行为，我们一般称其为"去掉const性质"。一旦我们去掉了某个对象的const性质，编译器就不再阻止我们对该对象进行写操作了。如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，再使用const_cast执行写操作就会产生未定义的后果。
只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。

十二、运算符优先级表


一些术语：
1、






