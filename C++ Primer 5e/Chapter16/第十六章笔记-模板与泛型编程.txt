笔记：
一、定义模板
1、面向对象编程(OOP)和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于：OOP能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。
2、模板是C++泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。
3、在模板定义中，模板参数列表不能为空。在模板参数列表中，typename和class没有什么不同。
4、当我们调用一个函数模板时，编译器(通常)用函数实参来为我们推断模板实参。
5、编译器用推断出的模板参数来为我们实例化一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新"实例"。
6、类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。
7、当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。这些值必须是常量表达式，从而允许编译器在编译时实例化模板。
一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或（左值）引用。绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期。我们不能用一个普通(非static)局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用nullptr或一个值为0的常量表达式来实例化。
8、非类型模板参数的模板实参必须是常量表达式。
9、函数模板可以声明为inline或constexpr的，如同非模板函数一样。inline或constexpr说明符放在模板参数列表之后，返回类型之前。
10、模板程序应该尽量减少对实参类型的要求。
11、当编译器遇到一个模板定义时，它并不会生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。
12、通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。
模板则不同：为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包含声明也包括定义。
函数模板和类模板成员函数的定义通常放在头文件中。
13、模板的设计者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明。模板的用户必须包含模板的头文件，以及用来实例化模板的任何类型的头文件。
14、保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用者的责任。
15、与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。
16、一个类模板的每个实例都形成一个独立的类。
17、与其他任何类相同，我们既可以在类模板内部，也可以在类模板外部为其定义成员函数，且定义在类模板内的成员函数被隐式声明为内联函数。
18、默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化。
如果一个成员函数没有被使用，则它不会被实例化。成员函数只有在被用到时才进行实例化，这一特性使得即使某种类型不能完全符合模板操作的要求，我们仍然能用该类型实例化类。
默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。
19、当我们使用一个类模板类型时必须提供模板实参，但这一规则有一个例外。在类模板自己的作用域中，我们可以直接使用模板名而不提供实参。
当我们在类模板外定义其成员时，必须记住，我们并不在类的作用域中，直到遇到类名才表示进入类的作用域。
20、当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。如果一个类模板包括一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。
21、类模板与另一个(类或函数)模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。
22、为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。
23、在新标准中，我们可以将模板类型参数声明为友元。
24、类似任何其他成员函数，一个static成员函数只有在使用时才会实例化。
25、一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。
注意，在模板内不能重用模板参数名。一个模板参数名在一个特定模板参数列表中只能出现一次。
26、模板声明必须包含模板参数。
一个给定模板的每个声明和定义必须有相同数量和种类(即，类型或非类型)的参数。
27、一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。
28、默认情况下，C++语言假定通过作用域运算符访问的名字不是类型。
当我们希望通知编译器一个名字表示类型时，必须使用关键字typename，而不能使用class。
29、我们也可以提供默认模板实参。
与函数默认实参一样，对于一个模板参数，只有当它右侧的所有参数都有默认实参时，它才可以有默认实参。
30、一个类(无论是普通类还是类模板)可以包含本身是模板的成员函数。这种成员被称为成员模板。成员模板不能是虚函数。
31、

二、模板实参推断
1、


三、重载与模板
1、


四、可变参数模板
1、


五、模板特例化
1、


一些术语：
1、






















