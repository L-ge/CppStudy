笔记：
一、顺序容器概述
1、元素在顺序容器中的顺序与其加入容器时的位置相对应。关联容器中元素的位置由元素相关联的关键字值决定。
2、顺序容器类型：
①vector：可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。
②deque：双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。
③list：双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快。
④forward_list：单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。(不支持size()操作、forward_list迭代器不支持递减操作符)
⑤array：固定大小数组。支持快速随机访问。不能添加或者删除元素。
⑥string：与vector相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快。

3、现代C++程序应该使用标准库容器，而不是更原始的数据结构，如内置数组。
4、以下是一些选择容器的基本原则：
①除非你有很好的理由选择其他容器，否则应使用vector。
②如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list。
③如果程序要求随机访问元素，应使用vector或deque。
④如果程序要求在容器的中间插入或删除元素，应使用list或forward_list。
⑤如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque。
⑥如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则：
-首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向vector追加数据，然后再调用标准库的sort函数。
-如果必须在中间位置插入元素，考虑在输入阶段使用list，一旦输入完成，将list中的内容拷贝到一个vector中。

5、如果不确定应该使用哪种容器，那么可以在程序中只使用vector和list公共的操作：使用迭代器，不使用下标操作，避免随机访问。这样，在必要时选择使用vector或list都很方便。

二、容器库概览
1、容器均定义为模板类。
2、较旧的编译器可能需要在两个尖括号之间键入空格，例如,vector<vector<string> >.
3、顺序容器构造函数的一个版本接受容器大小参数，它使用了元素类型的默认构造函数。但某些类没有默认构造函数。我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能只传递给它一个元素数目参数：
// 假定noDefault是一个没有默认构造函数的类型
vector<noDefault> v1(10, init);	// 正确：提供了元素初始化器
vector<noDefault> v1(10);		// 错误：必须提供一个元素初始化器
4、《C++ Primer 5e》P295列出了容器支持的操作。
5、迭代器end可以与迭代器begin指向相同的位置，但不能指向begin之前的位置。
6、反向迭代器就是一种反向遍历容器的迭代器，与正向迭代器相比，各种操作的含义也都发生了颠倒。例如，对一个反向迭代器执行++操作，会得到上一个元素。
7、begin和end操作生成指向容器中第一个元素和尾元素之后位置的迭代器。这两个迭代器最常见的用途是形成一个包含容器中所有元素的迭代器范围。
8、begin和end有多个版本：带r的版本返回反向迭代器；以c开头的版本则返回const迭代器。不以C开头的函数都是被重载过的，一个是const成员，另一个是非常量成员。
9、当不需要写访问时，应使用cbegin和cend。
10、每个容器类型都定义了一个默认构造函数。除array之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数。
11、只有顺序容器(不包括array)的构造函数才能接受大小参数，关联容器并不支持。
12、将一个新容器创建为另一个容器的拷贝的方法有两种：可以直接拷贝整个容器，或者(array除外)拷贝由一个迭代器对指定的元素范围。
13、当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器的元素类型即可。
14、如果元素类型是内置类型或者是具有默认构造函数的类类型，可以只为构造函数提供一个容器大小参数。如果元素类型没有默认构造函数，除了大小参数外，还必须指定一个显式的元素初始值。
15、我们不能对内置数组类型进行拷贝或对象赋值操作，但array并无此限制。
16、赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而swap操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效(容器类型为array和string的情况除外)。
17、顺序容器(array除外)定义了一个名为assign的成员，允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。assign操作不适用于关联容器和array。由于其旧元素被替换，因此传递给assign的迭代器不能指向调用assign的容器。
18、swap操作交换两个相同类型容器的内容。除array外，交换两个容器内容的操作保证会很快——元素本身并未交换，swap只是交换了两个容器的内部数据结构。
19、除array外，swap不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。元素不会被移动的事实意味着，除string外，指向容器的迭代器、引用或指针在swap操作之后都不会失效。它们仍指向swap操作之前所指向的那些元素，但是在swap之后，这些元素已经属于不同的容器了。
20、与其他容器不同，对一个string调用swap会导致迭代器、引用和指针失效。
21、与其他容器不同，swap两个array会真正交换它们的元素。因此，交换两个array所需的时间与array中元素的数目成正比。
22、统一使用非成员版本的swap是一个好习惯。
23、forward_list支持max_size和empty，但不支持size。
24、比较两个容器实际上是进行元素的逐对比较。这些运算符的工作方式与string的关系运算类似。
25、只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。

三、顺序容器操作
1、除array外，所有标准库容器在运行时都可以动态添加或删除元素来改变容器大小。
2、向一个vector、string或deque插入元素会使所有指向容器的迭代器、引用和指针失效。
3、除array和forward_list之外，每个顺序容器(包括string类型)都支持push_back.
4、当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。就像我们将一个对象传递给非引用参数一样，容器中的元素与提供值的对象之间没有任何关联。随后对容器中的元素的任何改变都不会影响到原始对象，反之亦然。
5、deque像vector一样提供了随机访问元素的能力，但它提供了vector所不支持的push_front.
6、insert函数将元素插入到迭代器所指定的位置之前。注意，将元素插入到vector、deque和string中的任何位置都是合法的，然而这样做可能很耗时。
7、在新标准下，接受元素个数或范围的insert版本返回指向第一个新加入元素的迭代器。所以，通过使用insert的返回值，可以在容器中一个特定位置反复插入元素。
8、新标准中引入了三个新成员——emplace_front、emplace和emplace_back，这些操作构造而不是拷贝元素。emplace函数在容器中直接构造元素。传递给emplace函数的参数必须与元素类型的构造函数相匹配。
9、如果容器中没有元素，访问操作的结果是未定义的。对一个空容器调用front和back，就像使用一个越界的下标一样，是一种严重的程序设计错误。
10、包括array在内的每个顺序容器都有一个front成员函数，而除forward_list之外的所有顺序容器都有一个back成员函数。这两个操作分别返回首元素和尾元素的引用。
11、在容器中访问元素的成员函数(即front、back、下标和at)返回的都是引用。

四、vector对象是如何增长的


五、额外的string操作


六、容器适配器



一些术语：
1、




