笔记：
一、IO类
1、iostream定义了用于读写流的基本类型，fstream定义了读写命名文件的类型，sstream定义了读写内存string对象的类型。
2、我们不能拷贝或对IO对象赋值。
由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。
读写一个IO对象会改变其状态，因此传递和返回的引用不能是const。
3、《C++ Primer 5e》P279-表8.2列出了IO类所定义的一些函数和标志，可以帮助我们访问和操纵流的条件状态。(例如eof()函数)
4、确定一个流对象的状态的最简单的方法是将它当作一个条件来使用，如：
while(cin >> word){
	...
}

5、每个输出流都管理一个缓冲区，用来保存程序读写的数据。
导致缓存刷新(即，数据真正写到输出设备或文件)的原因有很多：
①程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行。
②缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。
③我们可以使用操纵符如endl来显式刷新缓冲区。
④在每个输出操作之后，我们可以用操纵符unitbuf设置流的内部状态，来清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。
⑤一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin和cerr都关联到cout。因此，读cin或写cerr都会导致cout的缓冲区被刷新。

6、操纵符endl完成换行并刷新缓冲区的工作。
flush刷新缓冲区，但不输出任何额外的字符。
ends向缓冲区插入一个空字符，然后刷新缓冲区。

7、如果想在每次输出操作后都刷新缓冲区，我们可以使用unitbuf操纵符。它告诉流在接下来的每次写操作之后都进行一次flush操作。而nounitbuf操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制。

8、如果程序异常终止，输出缓冲区是不会被刷新的。当一个程序崩溃后，它所输出的数据很可能停留在输出缓冲区中等待打印。

9、使用tie函数来关联流或者解开流的关联。
每个流同时最多关联到一个流，但是多个流可以同时关联到同一个ostream。

二、文件输入输出
1、当我们想要读写一个文件时，可以定义一个文件流对象，并将对象与文件关联起来。
2、创建文件流对象时，我们可以提供文件名(可选的)。如果提供了一个文件名，则open会自动被调用。
3、文件流成功关闭已经关联的文件后，可以将文件流关联到另外一个文件。
4、当一个fstream对象离开其作用域时，与之关联的文件会自动关闭。
(当一个fstream对象被销毁时，close会自动被调用)
5、每个流文件都有一个关联的文件模式。(例如只读、只写等)
6、《C++ Primer 5e》P286-表8.4列出了文件模式和它们的定义。
7、默认情况下，当我们打开一个ofstream时，文件的内容会被丢弃。阻止一个ofstream清空给定文件内容的方法是同时指定app模式(每次写操作前均定位到文件末尾)。
8、对于一个给定流，每当打开文件时，都可以改变其文件模式。
在每次打开文件时，都要设置文件模式，可能是显式地设置，也可能是隐式地设置。当程序未指定模式时，就使用默认值。

三、string流
1、sstream头文件定义了三个类型来支持内存IO，这些类型可以向string写入数据，从string读取数据，就像string是一个IO流一样。
istringstream从string读取数据，ostringstream向string写入数据，而头文件stringstream即可从string读数据也可向string写数据。
2、当我们的某些工作是对整行文本进行处理，而其他一些工作是处理行内的单个单词时，通常可以使用istringstream。
3、当我们逐步构造输出，希望最后一起打印时，ostringstream是很有用的。

一些术语：
1、C++使用标准库类来处理面向流的输入和输出：
①iostream处理控制台IO；
②fstream处理命名文件IO；
③stringstream完成内存string的IO。
2、类fstream和stringstream都是继承自类iostream的。输入类都继承自istream，输出类都继承自ostream。
3、字符串流：用于读写string的流对象。除了普通的iostream操作外，字符串流还定义了一个名为str的重载成员。调用str的无参版本会返回字符串流关联的string。调用时传递给它一个string参数，则会将字符串流与该string的一个拷贝相关联。
