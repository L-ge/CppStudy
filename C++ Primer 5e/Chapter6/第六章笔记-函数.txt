笔记：
一、函数基础
1、在C++语言中允许重载函数，也就是几个不同的函数可以使用同一个名字。
2、实参是形参的初始值。
尽管实参与形参存在对应关系，但是并没有规定实参的求值顺序。编译器能以任意可行的顺序对实参求值。
实参的类型必须与对应的形参类型匹配，但有时存在实参隐式转换，例如实参是double、形参是int。
3、任意两个形参不能同名，而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字。
4、函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。
5、在C++语言中，名字有作用域，对象有生命周期。名字的作用域是程序文本的一部分，名字在其中可见。对象的生命周期是程序执行过程中该对象存在的一段时间。
在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结果才会销毁。局部变量的生命周期依赖于定义的方式。
6、我们把只存在于块执行期间的对象称为自动对象。
对于局部变量对应的自动对象来说，则分为两种情况：如果变量定义本身含有初始值，就用这个初始值进行初始化；否则，如果变量定义本身不含初始值，执行默认初始化。这意味着内置类型的未初始化局部变量将产生未定义的值。
7、某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成static类型从而获得这样的局部静态对象。该对象所在的函数在第一次执行时该静态对象被初始化，后面再次执行该函数，该静态对象不会被再次初始化。
8、如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0.
9、和其他名字一样，函数的名字也必须在使用之前声明。函数只能定义一次，但可以声明多次。唯一的例外是，如果一个函数永远也不会被我们用到，那么它可以只有声明没有定义。
函数的声明和函数的定义非常类似，唯一的区别是函数声明无须函数体，用一个分号替代即可。
函数声明也称作函数原型。
和变量类似，函数也应该在头文件中声明而在源文件中定义。定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。
10、为了允许编写程序时按照逻辑关系将其划分开来，C++语言支持所谓的分离式编译。分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。如果我们修改了其中一个源文件，那么只需重新编译那个改动了的文件。
大多数编译器提供了分离式编译每个文件的机制，这一过程通常会产生一个后缀名是.obj(Windows)或.o(UNIX)的文件，后缀名的含义是该文件包含对象代码。接下来编译器负责把对象文件链接在一起形成可执行文件。

二、参数传递
1、每次调用函数时都会重新创建它的形参，并用传入的实参对形参进行初始化。
形参初始化的机理与变量初始化一样。
2、当形参是引用类型时，我们说它对应的实参被引用传递或者函数被传引用调用。和其他引用一样，引用形参也是它绑定的对象的别名；也就是说，引用形参是它对应的实参的别名。
当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被值传递或者函数被传值调用。
3、当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。因为指针使我们可以间接地访问它所指的对象，所以通过指针可以修改它所指对象的值。
4、熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。在C++语言中，建议使用引用类型的形参替代指针。
5、拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型(包括IO类型在内)根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。
注意：如果函数无须改变引用形参的值，最好将其声明为常量引用。
6、一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个结果提供了有效的途径。
7、当形参是const时，必须要注意是否是顶层const。顶层const作用于对象本身。
和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const。当形参有顶层const时，传给它常量对象或者非常量对象都是可以的。
8、在C++语言中，允许我们定义若干具有相同名字的函数，不过前提是不同函数的形参列表应该有明显的区别。
void fcn(const int i){}	// fcn能读取i，但是不能向i写值
void fcn(int i){}		// 错误：重复定义了fcn(int)

9、形参的初始化方式和变量的初始化方式是一样的。我们可以使用非常量初始化一个底层const对象，凡是反过来不行；同时一个普通的引用必须用同类型的对象初始化。
C++不允许用字面值初始化一个非常量引用，允许我们用字面值初始化常量引用。

10、尽量使用常量引用。把函数不会改变的形参定义成(普通的)引用是一种比较常见的错误，这样做带给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。例如，我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。

11、因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。

12、尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：
// 下面3个print函数是等价的，都有一个const int*类型的形参
void print(const int*);
void print(const int[]);	// 可以看出来，函数的意图是作用于一个数组
void print(const int[10]);	// 这里的维度表示我们期望数组含有多少元素，实际不一定

13、和其他使用数组的代码一样，以数组作为形参的函数也必须确保使用数组时不会越界。

14、因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。管理指针形参有三种常用的技术。
①管理数组实参的第一种方法是要求数组本身包含一个结束标记，使用这种方法的典型示例是C风格字符串。C风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符。函数在处理C风格字符串时遇到空字符停止。这种方法适用于那些有明显结束标记且该标记不会与普通数据混淆的情况，但是那些像int这样所有取值都是合法值的数据就不太有效了。
②管理数组实参的第二种方法是传递指向数组首元素和尾后元素的指针。
③管理数组实参的第三种方法是专门定义一个表示数组大小的形参。

15、当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。

16、&arr两端的括号必不可少：
f(int &arr[10]);	// 错误：将arr声明成了引用的数组
f(int (&arr)[10]);	// 正确：arr是具有10个整数的整型数组的引用
但这一用法限制了函数的可用性，我们只能将函数作用于大小为10的数组。

17、下面两个语句等价：
void print(int (*matrix)[10], int rowSize) {}
void print(int matrix[][10], int rowSize) {}
matrix的声明看起来是一个二维数组，实际上形参是指向含有10个整数的数组的指针。
*matrix两端的括号必不可少：
int *matrix[10];	// 10个指针构成的数组
int (*matrix)[10];	// 指向含有10个整数的数组的指针

18、当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入。
int main(int argc, char *argv[]) { ... } // 第一个形参argc表示数组中字符串的数量，第二个形参argv是一个数组，它的元素是指向C风格字符串的指针。当实参传给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素一依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。

19、C++有一种特殊的形参类型(即省略符)，可以用它传递可变数量的实参。不过需要注意的是，省略符形参这种功能一般只用于与C函数交互的接口程序。
省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。
省略符形参只能出现在形参列表的最后一个位置，它的形式无外乎以下两种：
void foo(parm_list, ...);
void foo(...);
省略符形参所对应的实参无须类型检查。

20、如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。initializer_list类型定义在同名的头文件中。
拷贝或赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。
initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。

三、返回类型和return语句
1、注意：在含有return语句的循环后面应该也有一条return语句，如果没有的话该程序就是错误的。很多编译器都无法发现此类错误。
2、不要返回局部对象的引用或指针。函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域。
3、函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。
特别是，我们能为返回类型是非常量引用的函数的结果赋值：
char &get_val(string &str, string::size_type ix){	return str[ix];	}
get_val(s, 0) = 'A';	// 将s[0]的值改为A

4、C++11新标准规定，函数可以返回花括号包围的值的列表。

5、我们允许main函数没有return语句直接结束。如果控制到达了main函数的结尾处而且没有return语句，编译器将隐式地插入一条返回0的return语句。
main函数不能调用自己。

6、逐层理解该声明的含义：int (*func(int i))[10];
①func(int i)表示调用func函数时需要一个int类型的实参。
②(*func(int i))意味着我们可以对函数调用的结果执行解引用操作。
③(*func(int i))[10]表示解引用func的调用将得到一个大小是10的数组。
④int (*func(int i))[10]表示数组中的元素是int类型。

7、在C++11新标准中海油一种可以简化上述func声明的方法，就是使用尾置返回类型。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以一个->符号开头。
auto func(int i) -> int(*)[10];	// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组
因为我们把函数的返回类型放在了形参列表之后，所以可以清楚地看到func函数返回的是一个指针，并且该指针指向了含有10个整数的数组。

8、如果我们知道函数返回的指针将指向哪个数组，就可以使用decltype关键字声明返回类型。
int odd[] = {1,3,5,7,9};
int even[] = {0,2,4,6,8};
decltype(odd) *arrPtr(int i)
{
	return (i % 2) ? &odd : &even;	// 返回一个指向数组的指针
}
arrPtr使用关键字decltype表示它的返回类型是个指针，并且该指针所指的对象与odd的类型一致。因为odd是数组，所以arrPtr返回一个指向含有5个整数的数组的指针。有个地方需要注意：decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，要想表示arrPtr返回指针还必须在函数声明时加一个*符号。

四、函数重载
1、如果同一个作用域内的几个函数名字相同但形参列表不同，我们称之为重载函数。
main函数不能重载。
2、

五、特殊用途语言特性
1、

六、函数匹配
1、

七、函数指针
1、

一些术语：
1、





















