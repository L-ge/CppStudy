笔记：
一、定义抽象数据类型
1、类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程(以及设计)技术。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。

2、成员函数的声明必须在类的内部，它的定义则既可以在类的内部也可以在类的外部。

3、任何对类成员的直接访问都被看作this的隐式引用。this是一个常量指针，我们不允许改变this中保存的地址。

4、默认情况下，this的类型是指向类类型的非常量版本的常量指针。
C++语言将this声明成指向常量的指针的做法是允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常量成员函数。因为这里this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容。
注意：常量对象，以及常量对象的引用或指针都只能调用常量成员对象。

5、成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。因为编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体(如果有的话)。

6、我们定义非成员函数的方式与定义其他函数一样，通常把函数的声明和定义分离开来。如果函数在概念上属于类但是不定义在类中，则它一般应与类声明(而非定义)在同一个头文件内。在这种方式下，用户使用接口的任何部分都只需要引入一个文件。

7、IO类属于不能拷贝的类型，因此我们只能通过引用来传递它们。
8、默认情况下，拷贝类的对象其实拷贝的是对象的数据成员。

9、构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。

10、构造函数不能被声明成const的。

11、类通过一个特殊的构造函数来控制默认初始化过车，这个函数叫做默认构造函数。默认构造函数无须任何实参。
编译器创建的构造函数又被称为合成的默认构造函数。

12、合成的默认构造函数只适合非常简单的类。对于一个普通的类来说，必须定义它自己的默认构造函数，原因有三：
第一个原因也是最容易理解的一个原因就是只有在发现类不包括任何构造函数的情况下才会替我们生成一个默认的构造函数。一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。
第二个原因是对于某些类来说，合成的默认构造函数可能执行错误的操作。如果定义在块内的内置类型或复合类型(比如数组和指针)的对象被默认初始化，则它们的值将是未定义的。因此，含有内置类型或复合类型成员的类应该在类的内部初始化这些成员，或者定义一个自己的默认构造函数。否则，用户在创建类的对象时就可能得到未定义的值。
第三个原因是有的时候编译器不能为某些类合成默认的构造函数。例如，如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。对于这样的来说，我们必须自定义默认构造函数，否则该类将没有可用的默认构造函数。

13、下面构造函数不接受任何实参，所以它是一个默认构造函数。在C++11新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上= default来要求编译器生成构造函数。其中，= default既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果= default在类的内部，则默认构造函数是内联的；如果它在类的外部，则该成员默认情况下不是内联的。
AMainWork() = default;

14、构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值(某些编译器可能不支持)，则所有构造函数都应该显式地初始化每个内置类型的成员。

15、尽管编译器能替我们合成拷贝、赋值和销毁的操作，但是必须要清楚的一点是，对于某些类来说合成的版本无法正常工作。特别是，当类需要分配类对象之外的资源时，合成的版本常常会失效。
不过值得注意的是，很多需要动态内存的类能(而且应该)使用vector对象或者string对象管理必要的存储空间。使用vector或者string的类能避免分配和释放内存带来的复杂性。

二、访问控制与封装
1、我们可以使用class和struct两个关键字中的任何一个定义类。唯一的一点区别是，class和struct的默认访问权限不太一样。
类可以在它的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式。如果我们使用struct关键字，则定义在第一个访问说明符之前的成员是public的；相反，如果我们使用class关键字，则这些成员是private的。
出于统一编程风格考虑，当我们希望定义的类的所有成员是public的时候，使用struct；反之，如果希望成员是private的，使用class。
注意：使用class和struct定义类唯一的区别就是默认的访问权限。

2、类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元。如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可。

3、友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。
一般来说，最好在类定义开始或结束前的位置集中声明友元。

4、封装有两个重要的优点：
①确保用户代码不会无意间破坏封装对象的状态。
②被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。

5、友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在(类内部的)友元声明之外再专门对函数进行一次声明(除了类内部的友元声明之外)。为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中(类的外部)。
许多编译器并未强制限定友元函数必须在使用之前在类的外部声明。

三、类的其他特性
1、用了定义类型的成员必须先定义后使用，这一点与普通成员有所区别。因此，类型成员通常出现在类开始的地方。
typedef std::string::size_type pos;
using pos = std::string::size_type;
由类定义的类型名字和其他成员一样存在访问限制，可以是public或者private中的一种。

2、我们使用=default告诉编译器为我们合成默认的构造函数。

3、定义在类内部的成员函数是自动inline的。我们可以在类的内部把inline作为声明的一部分显式地声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义。
(虽然我们无须在声明和定义的地方同时说明inline，但这么做其实是合法的。不过最好只在类外部定义的地方说明inline，这样可以使类更容易理解)

4、可以通过在变量的声明中加入mutable关键字，使我们能够修改类的某个数据成员，即使是在一个const成员函数内。

5、一个可变数据成员永远不会是const，即使它是const对象的成员。因此，一个const成员函数可以改变一个可变成员的值。

6、类内初始值必须使用=的初始化形式(初始化类的数据成员时所用)或者花括号括起来的直接初始化形式(例如初始化该类类型的vector所用的)。

7、返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本。

8、一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用。

9、通过区分成员函数是否是const的，我们可以对其进行重载，其原因与我们之前根据指针参数是否指向const而重载函数的原因差不多。具体说来，因为非常量版本的函数对于常量对象是不可用的，所以我们只能在一个常量对象上调用const成员函数。另一方面，虽然可以在非常量对象上调用常量版本或非常量版本，但显然此时非常量版本是一个更好的匹配。

10、我们可以把类名作为类型的名字使用，从而直接指向类类型。或者我们也可以把类名跟在关键字class或struct后面：
AMainWork w;		// 默认初始化AMainWork类型的对象
class AMainWork w;	// 一条等价的声明

11、就像可以把函数的声明和定义分离开来一样，我们也能仅仅声明类而暂时不定义它：
class AMainWork;	// AMainWork类的声明
这种声明有时被称作前向声明，它向程序中引入了名字AMainWork并且指明AMainWork是一种类类型。对于类型AMainWork来说，在它声明之后定义之前是一个不完全类型，也就是说，此时我们已知AMainWork是一个类类型，但是不清楚它到底包括哪些成员。
不完全类型只能在非常有限的情境下使用：可以定义指向这种类型的指针或引用，也可以声明(但是不能定义)以不完全类型作为参数或者返回类型的函数。

12、对于一个类来说，在我们创建它的对象之前该类必须被定义过，而不能仅仅被声明。否则，编译器就无法了解这样的对象需要多少存储空间。

13、只有当类全部完成后类才算被定义，所以一个类的成员类型不能是该类自己。然而，一旦一个类的名字出现后，它就被认为是声明过了(但尚未定义)，因此类允许包含指向它自身类型的引用或指针。

14、如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。(但需要注意的是，友元关系不存在传递性，每个类负责控制自己的友元类或友元函数)
class AMainWork
{
	// ADevManager的成员可以访问AMainWork类的私有部分
	friend class ADevManager;
	// AMainWork类的剩余部分
	...
}

15、除了令整个ADevManager作为友元之外，AMainWork还可以只为ADevManager类的func函数提供访问权限。
class AMainWork
{
	// ADevManager::func必须在AMainWork类之前被声明
	friend void ADevManager::func(int);
	// AMainWork类的剩余部分
	...
}
要想令某个成员函数作为友元，我们必须仔细组织成员的结构以满足声明和定义的彼此依赖关系。在上面的例子中，我们必须按照如下方式设计程序：
①首先定义ADevManager类，其中声明func函数，但是不能定义它。在func函数使用AMainWork的成员之前必须先声明AMainWork。
②接下来定义AMainWork，包括对于func的友元声明。
③最后定义func，此时它才可以使用AMainWork的成员。

16、如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明。

17、类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中。
甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的。
struct X
{
	friend void f() { /* 友元函数可以定义在类的内部 */ }
	X() { f(); }			// 错误：f还没有被声明
	void g();
	void h();
}
void X::g() { return f(); } // 错误：f还没有被声明
void f();					// 声明那个定义在X中的函数
void X::h() { return f(); }	// 正确：现在f的声明在作用域中了
关于这段代码最重要的是理解友元声明的作用是影响访问权限，它本身并非普通意义上的声明。

四、类的作用域
1、在类的作用域之外，普通的数据和函数成员只能由对象、引用或者指针使用成员访问运算符来访问。对于类类型成员则使用作用域运算符访问。

2、函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。这时，返回类型必须指明它是哪个类的成员。(成员函数的形参列表则不需要指明它是哪个类的成员)

3、编译器处理完类中的全部声明后才会处理成员函数的定义。

4、类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。

5、可以通过作用域运算符::访问外层被隐藏掉的对象。

五、构造函数再探
1、如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化。
版本①：
AMainWork::AMainWork(int a){
	m_nCnt = a;
}
与版本②： 
AMainWork::AMainWork(int a) : m_nCnt(a){
}
这两个方法效果一样。区别是版本①是先默认初始化，然后对数据成员执行了赋值操作；版本②是初始化了它的数据成员。这一区别到底会有什么深层次的影响完全依赖于数据成员的类型。

2、有时我们可以忽略数据成员初始化和赋值之间的差异，但并非总能这样。如果成员是const或者是引用的话，必须将其初始化。类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。
如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。
建议使用构造函数初始值。在很多类中，初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员，后者则先初始化再赋值。

3、构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。
成员的初始化顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。
注意：最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。
如果可能的话，最好用构造函数的参数作为成员的初始值，而尽量避免使用同一个对象的其他成员。这样的好处是我们可以不必考虑成员的初始化顺序。

4、如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。

5、一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些(或者全部)职责委托给了其他构造函数。
在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身。
class AMainWork
{
public:
	// 非委托构造函数使用对应的实参初始化成员
	AMainWork(int nCnt, int nPrice) : m_nCnt(nCnt), m_nPrice(nPrice) {}
	// 其他构造函数全都委托给另一个构造函数
	AMainWork() : AMainWork(0, 0) {}
	AMainWork(int nCnt) : AMainWork(nCnt, 0) {}
	AMainWork(string s) : AMainWork() {}
}
	
6、在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数。

7、一种常犯的错误，试图以如下的形式声明一个用默认构造函初始化的对象：
AMainWork w1();	// 错误：声明了一个函数而非对象 
AMainWork w2;	// 正确：w2是一个对象而非函数

8、如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称作转换构造函数。
能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。
类AMainWork有如下一个成员函数：
AMainWork& func(const AMainWork&) { ... }
和如下一个构造函数：
AMainWork(string s) : AMainWork() {}
则：
string sTmp = "abcd";
w.func(sTmp);	// 这里构造了一个临时的AMainWork对象
该调用是合法的，编译器用给定的string自动创建了一个AMainWork对象。新生成的这个(临时)AMainWork对象被传递给func。因为func的参数是一个常量引用，所以我们可以给该参数传递一个临时量。
但是，编译器只会自动地执行一步类型转换。下面代码错误，因为隐式地使用了两次转换规则：
w.func("abcd");	// ①把"abcd"转换成string; ②再把这个(临时的)string转换成AMainWork
我们可以如下实现：
w.func(string("abcd"));		// 正确：显式地转换成string，隐式地转换成AMainWork
w.func(AMainWork("abcd"));	// 正确：隐式地转换成string，显式地转换成AMainWork

9、在要求隐式转换的程序的上下文中，我们可以通过将构造函数声明为explicit加以阻止：
类AMainWork构造函数改为：
explicit AMainWork(string s) : AMainWork() {}
则下面语句编译不通过，因为string构造函数是explicit的：
string sTmp = "abcd";
w.func(sTmp);	

10、关键字只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为explicit。
另外，只能在类内声明构造函数时使用explicit关键字，在类外部定义时不应重复。

11、发生隐式缓缓的一种情况是当我们执行拷贝爱形式的初始化时(使用=)。此时，我们只能使用直接初始化而不能使用explicit构造函数：
string sTmp = "abcd";
AMainWork w1(sTmp);		// 正确：直接初始化
AMainWork w2 = sTmp;	// 错误：不能将explicit构造函数用于拷贝形式的的初始化过程
所以，当我们用explicit关键字声明构造函数时，它将只能以直接初始化的形式使用。而且，编译器将不会在自动转换过程中使用该构造函数。

12、尽管编译器不会将explicit的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显式地强制进行转换：
string sTmp = "abcd";
w.func(AMainWork(sTmp));				// 正确：实参是一个显示构造的AMainWork对象
w.func(static_cast<AMainWork>(sTmp));	// 正确：static_cast可以使用explicit的构造函数(我们使用static_cast执行了显式的而非隐式的转换。其中，static_cast使用string构造函数创建了一个临时的AMainWork对象)

13、一些标准库中的类含有单参数的构造函数：
①接受一个单参数的const char*的string构造函数不是explicit的；
②接受一个容量参数的vector构造函数是explicit的。

14、聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。
当一个类满足如下条件时，我们说它是聚合的：
①所有成员都是public的；
②没有定义任何构造函数；
③没有类内初始值；
④没有基类，也没有virtual函数。
例如,下面的类是一个聚合类：
struct Data{
	int nVal;
	string s;
};
我们可以提供一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员：
Data d = { 0, "abcd" };
注意，初始值的顺序必须与声明的顺序是一致的。另外，与初始化数组元素的规则一样，如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。初始值列表的元素个数绝对不能超过类的成员数量。
值得注意的是，显示地初始化类的对象的成员存在三个明显的缺点：
①要求类的所有成员都是public的。
②将正确初始化每个对象的每个成员的重任交给了类的用户(而非类的作者)。因为用户很容易忘掉某个初始值，或者提供一个不恰当的初始值，所以这样的初始化过程冗长乏味且容易死出错。
③添加或删除一个成员之后，所有的初始化语句都需要更新。

15、constexpr函数的参数和返回值必须是字面值类型。除了算术类型、引用和指针外，某些类也是字面值类型。
和其他类不同，字面值类型的类可能包含constexpr函数成员。这样的成员必须符合constexpr函数的所有要求，它们是隐式const的。

16、数据成员都是字面值类型的聚合类是字面值常量类。如果一个类不是聚合类，但它符合下述要求，则它也是一个字面值常量类：
①数据成员都必须是字面值类型。
②类必须至少含有一个constexpr构造函数。
③如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。
④类必须使用析构函数的默认定义，该成员负责销毁类的对象。

17、尽管构造函数不能是const的，但是字面值常量类的构造函数可以是constexpr函数。
constexpr构造函数可以声明成=default的形式(或者是删除函数的形式)。否则，constexpr构造函数就必须既符合构造函数的要求(意味着不能包含返回语句)，又符合constexpr函数的要求(意味着它能拥有的唯一的可执行语句就是返回语句)。所以，constexpr构造函数体一般来说应该是空的。
我们通过前置关键字constexpr就可以声明一个constexpr构造函数了。

18、constexpr构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是一条常量表达式。
constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型。

六、类的静态成员
1、有的时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。
我们通过在成员的声明之前加上关键字static使得其与类关联在一起。
静态成员可以是public的或private的。
静态数据成员的类型可以是常量、引用、指针、类类型等。

2、类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。
类似的，静态成员函数也不与任何对象绑定在一起，它们不包含thiis指针。作为结果，静态成员函数不能声明成const的，而且我们不能再static函数体内使用this指针。这一限制既适用于this的显式使用，也对调用非静态成员的隐式使用有效。

3、虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针来访问静态成员。
成员函数不用通过作用域运算符就能直接使用静态成员。

4、当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句。
因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。

5、类似于全局变量，静态数据成员定义在任何函数之外。因为一旦它被定义，就将一直存在于程序的整个生命周期中。
要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中。

6、即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。

7、静态数据成员可以是不完全类型。
静态数据成员的类型可以就是它所属的类类型，而非静态数据成员则受限制，只能声明成它所属类的指针或引用。

8、静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参。
非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终将引发错误。
class AMainWork
{
public:
	void func(char c = cTmp);	// cTmp表示一个在类中稍后定义的静态成员
private:
	static const char cTmp;
};

一些术语：
1、类的声明：首先是关键字class(或者struct)，随后是类名以及分号。如果类已经声明而尚未定义，则它是一个不完全类型。
2、class关键字：用于定义类的关键字，默认情况下成员是private。
3、常量成员函数：一个成员函数，在其中不能修改对象的普通(即既不是static也不是mutable)数据成员。const成员的this指针是指向常量的指针，通过区分函数是否是const可以进行重载。
4、构造函数应该给每个数据成员都赋一个合适的初始值。
5、显示构造函数：可以用一个单独的实参调用但是不能用于隐式转换的构造函数。通过在构造函数的声明之前加上explicit关键字就可以将其声明成显式构造函数。
6、前向声明：对尚未定义的名字的声明，通常用于表示位于类定义之前的类声明。
7、不完全类型：已经声明但是尚未定义的类型。不完全类型不能用于定义变量或者类的成员，但是用不完全类型定义指针或者引用是合法的。
8、可变数据成员(mutable data member)：这种成员永远不是const，即使它属于const对象。在const函数内可以修改可变数据成员。
9、struct关键字：用于定义类的关键字，默认情况下成员是public。
10、合成默认构造函数：对于没有显式地定义任何构造函数的类，编译器为其创建(合成)的默认构造函数。该构造函数检查类的数据成员，如果提供了类内初始值，就用它执行初始化操作；否则就对数据成员执行默认初始化。
11、this指针是一个隐式的值，作为额外的实参传递给类的每个非静态成员函数。this指针指向代表函数调用者的对象。
12、=default：一种语法形式，位于类内部默认构造函数声明语句的参数列表之后，要求编译器生成构造函数，而不管类是否已经有了其他构造函数。
