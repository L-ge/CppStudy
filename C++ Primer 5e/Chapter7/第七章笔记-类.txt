笔记：
一、定义抽象数据类型
1、类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程(以及设计)技术。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。

2、成员函数的声明必须在类的内部，它的定义则既可以在类的内部也可以在类的外部。

3、任何对类成员的直接访问都被看作this的隐式引用。this是一个常量指针，我们不允许改变this中保存的地址。

4、默认情况下，this的类型是指向类类型的非常量版本的常量指针。
C++语言将this声明成指向常量的指针的做法是允许把const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作常量成员函数。因为这里this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容。
注意：常量对象，以及常量对象的引用或指针都只能调用常量成员对象。

5、成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。因为编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体(如果有的话)。

6、我们定义非成员函数的方式与定义其他函数一样，通常把函数的声明和定义分离开来。如果函数在概念上属于类但是不定义在类中，则它一般应与类声明(而非定义)在同一个头文件内。在这种方式下，用户使用接口的任何部分都只需要引入一个文件。

7、IO类属于不能拷贝的类型，因此我们只能通过引用来传递它们。
8、默认情况下，拷贝类的对象其实拷贝的是对象的数据成员。

9、构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。

10、构造函数不能被声明成const的。

11、类通过一个特殊的构造函数来控制默认初始化过车，这个函数叫做默认构造函数。默认构造函数无须任何实参。
编译器创建的构造函数又被称为合成的默认构造函数。

12、合成的默认构造函数只适合非常简单的类。对于一个普通的类来说，必须定义它自己的默认构造函数，原因有三：
第一个原因也是最容易理解的一个原因就是只有在发现类不包括任何构造函数的情况下才会替我们生成一个默认的构造函数。一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。
第二个原因是对于某些类来说，合成的默认构造函数可能执行错误的操作。如果定义在块内的内置类型或复合类型(比如数组和指针)的对象被默认初始化，则它们的值将是未定义的。因此，含有内置类型或复合类型成员的类应该在类的内部初始化这些成员，或者定义一个自己的默认构造函数。否则，用户在创建类的对象时就可能得到未定义的值。
第三个原因是有的时候编译器不能为某些类合成默认的构造函数。例如，如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。对于这样的来说，我们必须自定义默认构造函数，否则该类将没有可用的默认构造函数。

13、下面构造函数不接受任何实参，所以它是一个默认构造函数。在C++11新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上= default来要求编译器生成构造函数。其中，= default既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果= default在类的内部，则默认构造函数是内联的；如果它在类的外部，则该成员默认情况下不是内联的。
AMainWork() = default;

14、构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值(某些编译器可能不支持)，则所有构造函数都应该显式地初始化每个内置类型的成员。

15、尽管编译器能替我们合成拷贝、赋值和销毁的操作，但是必须要清楚的一点是，对于某些类来说合成的版本无法正常工作。特别是，当类需要分配类对象之外的资源时，合成的版本常常会失效。
不过值得注意的是，很多需要动态内存的类能(而且应该)使用vector对象或者string对象管理必要的存储空间。使用vector或者string的类能避免分配和释放内存带来的复杂性。

二、访问控制与封装
1、我们可以使用class和struct两个关键字中的任何一个定义类。唯一的一点区别是，class和struct的默认访问权限不太一样。
类可以在它的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式。如果我们使用struct关键字，则定义在第一个访问说明符之前的成员是public的；相反，如果我们使用class关键字，则这些成员是private的。
出于统一编程风格考虑，当我们希望定义的类的所有成员是public的时候，使用struct；反之，如果希望成员是private的，使用class。
注意：使用class和struct定义类唯一的区别就是默认的访问权限。

2、类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元。如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可。

3、友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。
一般来说，最好在类定义开始或结束前的位置集中声明友元。

4、封装有两个重要的优点：
①确保用户代码不会无意间破坏封装对象的状态。
②被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。

5、友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在(类内部的)友元声明之外再专门对函数进行一次声明(除了类内部的友元声明之外)。为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中(类的外部)。
许多编译器并未强制限定友元函数必须在使用之前在类的外部声明。

三、类的其他特性
1、用了定义类型的成员必须先定义后使用，这一点与普通成员有所区别。因此，类型成员通常出现在类开始的地方。
typedef std::string::size_type pos;
using pos = std::string::size_type;
由类定义的类型名字和其他成员一样存在访问限制，可以是public或者private中的一种。

2、我们使用=default告诉编译器为我们合成默认的构造函数。

3、定义在类内部的成员函数是自动inline的。我们可以在类的内部把inline作为声明的一部分显式地声明成员函数，同样的，也能在类的外部用inline关键字修饰函数的定义。
(虽然我们无须在声明和定义的地方同时说明inline，但这么做其实是合法的。不过最好只在类外部定义的地方说明inline，这样可以使类更容易理解)

4、可以通过在变量的声明中加入mutable关键字，使我们能够修改类的某个数据成员，即使是在一个const成员函数内。

5、一个可变数据成员永远不会是const，即使它是const对象的成员。因此，一个const成员函数可以改变一个可变成员的值。

6、类内初始值必须使用=的初始化形式(初始化类的数据成员时所用)或者花括号括起来的直接初始化形式(例如初始化该类类型的vector所用的)。

7、返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本。

四、类的作用域
1、


五、构造函数再探
1、



六、类的静态成员
1、


一些术语：
1、
